# 建造者模式
Builder 模式用于组装具有复杂结构的实例，组装的具体过程则被隐藏在 Director 角色中。

## 1 思路要点

### 1.1 谁知道什么

在面向对象编程中，“谁知道什么” 是非常 重要的。也就是说，我们需要在编程时注意哪个类可以使用哪个方法以及使用这个方法到底好不好。

在 [**sample**](https://github.com/305983806/neo-demo/tree/master/design-pattern/builder/sample) 中，Director 类不知道自己使用的究竟是 Builder 类的哪个子类，不论是将 **TextBuilder** 的实例传递给 **Director**，还是将 **HtmlBuilder** 类的实例传递给 **Director**，它都可以正常工作，原因正是 **Director** 类不知道 **Builder** 类的具体子类。

正是因为不知道才能够替换，正是因为可以替换，组件才具有高价值。作为设计 人员，我们必须时刻关注这种 “可替换性”。

### 1.2 设计时能够决定的事情和不能决定的事情

在 **Builder** 类中，需要声明编辑文档（实现功能）所必须的所有方法。**Director** 类中使用的方法都由 **Builder** 类提供。因此，在  **Builder** 类中应当定义哪些方法是非常重要的。

而且， **Builder** 类还必须能够应对将来子类可能增加的需求。在示例程序中，我们只编写了支持纯文本文档的子类和支持 **HTML** 文件的子类。但是将来可能会希望能够编写其他形式（例如 XXXX 形式）的文档。那时候，到底能不能编写出支持 XXXX 形式的 XXXXBuilder 类呢？应该不需要新的方法吧？

虽然类的设计者并不是神仙，他们无法准确地预测到将来可能发生的变化。但是我们还是有必要让设计出的类能够尽可能灵活地应用近期可能发生的变化。

### 1.3 代码的阅读方法和修改方法

虽然有时需要从零开始编写代码，但更多时候我们都是在现有代码的基础上进行增加和修改。

这时我们需要先阅读现有代码。不过只是阅读抽象类的代码是无法获取很多信息的（虽然可以从方法名中获得线索）。就拿示例程序来说，即使理解了 Builder 抽象类，也无法理解程序整体。至少必须在阅读了 Director 的代码后才能理解 Builder 类的使用方法（Builder类的方法的调用方法）。然后再去看 TextBuilder 类和 HTMLBuilder 类的代码，就可以明白调用 Builder 类的方法后具体会进行什么样的处理。

如果没有理解各个类的角色就动手增加和修改代码，在判断到底应该修改哪个类时，就会很容易出错。例如，如果修改 Builder 类，那么就会对 Director 类中调用 Builder 类方法的地方和 Builder 类的子类产生影响。或是如果不小心修改了 Director 类，在其内部调用了 TextBuilder 类的特有方法，则会导致其失去作为可利用组件的独立性，而且当将子类替换为 HTMLBuilder 时，程序可能会无法正常工作。